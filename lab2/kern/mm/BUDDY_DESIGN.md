# Buddy System 设计文档

## 算法原理

Buddy System（伙伴系统）是一种经典的内存分配算法，通过将内存块按 2 的幂次大小进行管理，实现快速分配和高效合并。

### 核心思想

1. **2的幂次管理**：所有内存块大小必须是 2^n 页（1, 2, 4, 8, 16, ...）
2. **伙伴关系**：相邻且大小相同的两个块互为伙伴，地址满足特定关系
3. **分裂**：当请求的块小于可用块时，将大块递归分裂成两个伙伴
4. **合并**：释放时检查伙伴块是否空闲，若是则合并成更大的块

### 数据结构

```c
// 使用多个空闲链表，每个链表管理固定大小的块
free_area_t free_area[MAX_ORDER];  // free_area[k] 管理 2^k 页的块
```

- `MAX_ORDER`：支持的最大阶数（如 MAX_ORDER=11 支持最大 2^10=1024 页）
- 每个 `free_area[k]` 维护大小为 2^k 页的空闲块链表

### 关键算法

#### 1. 初始化 (buddy_init_memmap)
- 计算可管理的最大块阶数
- 将整块内存插入对应的空闲链表
- 如果总页数不是 2 的幂次，分解成多个 2 的幂次块

#### 2. 分配 (buddy_alloc_pages)
```
输入：n 页
1. 计算需要的阶数 order = ceil(log2(n))
2. 在 free_area[order] 中查找
3. 如果找到：分配并返回
4. 如果未找到：在更高阶链表中查找
5. 找到更大块后，递归分裂直到达到目标大小
6. 返回分配的块
```

#### 3. 释放 (buddy_free_pages)
```
输入：base 地址, n 页
1. 计算块的阶数 order = ceil(log2(n))
2. 将块插入 free_area[order]
3. 循环尝试合并：
   a. 计算伙伴地址
   b. 检查伙伴是否空闲且大小匹配
   c. 若是，移除两个块，合并成更大块
   d. order++, 继续尝试合并更大块
```

#### 4. 伙伴地址计算
```c
// 块起始页号 page_idx，阶数 order
buddy_idx = page_idx ^ (1 << order);
```
通过异或运算快速计算伙伴的索引。

### 优势
- **快速合并**：O(log n) 时间复杂度，通过伙伴关系快速定位
- **减少碎片**：按 2 的幂次管理，合并效率高
- **简单高效**：数据结构简单，易于实现

### 劣势
- **内部碎片**：请求 n 页时分配 2^ceil(log2(n)) 页，可能浪费空间
- **固定大小**：只能分配 2 的幂次大小的块

## 实现要点

1. 使用 `struct Page` 的 `property` 字段存储块的阶数
2. 使用 `PG_property` 标志位标记空闲块的头页
3. 分配时清除 `PG_property`，释放时恢复
4. 合并时只保留低地址块的 `PG_property` 标记

## 测试用例

测试覆盖：
1. 基本分配和释放
2. 块分裂测试
3. 块合并测试
4. 边界情况（分配所有内存、释放所有内存）
5. 随机分配释放序列

